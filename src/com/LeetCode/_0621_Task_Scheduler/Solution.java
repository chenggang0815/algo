package com.LeetCode._0621_Task_Scheduler;
/*
621. Task Scheduler
给你一个用字符数组tasks表示的CPU需要执行的任务列表。其中每个字母表示一种不同种类的任务。
任务可以以任意顺序执行，并且每个任务都可以在1个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
然而，两个相同种类 的任务之间必须有长度为整数n的冷却时间，因此至少有连续n个单位时间内CPU在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间 。

示例 1：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。

示例 2：
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类

示例 3：
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
 */

/*
思路1：模拟

思路2：桶思想
我们设计桶的大小为 n+1，则相同的任务恰好不能放入同一个桶，最密也只能放入相邻的桶。
对于重复的任务，我们只能将每个都放入不同的桶中，因此桶的个数就是重复次数最多的任务的个数。
一个桶不管是否放满，其占用的时间均为 n+1，这是因为后面桶里的任务需要等待冷却时间。最后一个桶是个特例，由于其后没有其他任务需等待，所以占用的时间为桶中的任务个数。

最终我们得到：
总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数
最后，当任务重复率很低时，计算得到的桶个数很少。但由于任务很多，可能出现桶不够用的情况。
（此时可以假想在最后一桶之后又补充了很多个桶，且所有的桶均装满，因此任务的总等待时间即为任务的总个数）
应该理解成后面又补充了很多个桶，可以试着这样理解，每个桶的长度至少为n+1,当重复率比较低的时候，n+1长度的桶全部装满，
此时可以在前面的桶上任一扩展长度，只要把剩下的任务完全放进去即可，注意，这时候每个桶的长度可能不等，但是均可以保证间隔不低于n，
按桶顺序执行即可，于是可以得到 任务数即为总的最小耗时
 */
public class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] temp = new int[26];
        int lastBucketSize = 0;
        int maxTask  = 0;

        for (char c: tasks){
            temp[c - 'A']++;
            maxTask = Math.max(temp[c - 'A'], maxTask);
        }

        for (int i = 0; i < 26; i++){
            if (temp[i] == maxTask){
                lastBucketSize++;
            }
        }

        return Math.max(tasks.length, (maxTask - 1) * (n + 1) + lastBucketSize);
    }

    public static void main(String[] args) {

    }
}
