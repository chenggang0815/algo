package LeetCode._0089_Gray_Code;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

/*
89. Gray Code

An n-bit gray code sequence is a sequence of 2n integers where:
    Every integer is in the inclusive range [0, 2n - 1],
    The first integer is 0,
    An integer appears no more than once in the sequence,
    The binary representation of every pair of adjacent integers differs by exactly one bit, and
    The binary representation of the first and last integers differs by exactly one bit.
Given an integer n, return any valid n-bit gray code sequence.

Example 1:
Input: n = 2
Output: [0,1,3,2]
Explanation:
The binary representation of [0,1,3,2] is [00,01,11,10].
- 00 and 01 differ by one bit
- 01 and 11 differ by one bit
- 11 and 10 differ by one bit
- 10 and 00 differ by one bit
[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].
- 00 and 10 differ by one bit
- 10 and 11 differ by one bit
- 11 and 01 differ by one bit
- 01 and 00 differ by one bit
*/
/*
Solution
Approach: BackTracking
1. start from 0, we will have 2^n number, each time, we find all possible number
2. each time, use a for loop to find each possible number (next) that can be generated by changing one bit of the last number in the result list (current)
3. for example, n=4 current = 1010  ^ 异或运算，两个位相同则为0，不同则为1
                1010 ^ 0001 (i=1) => 1011 only change one bit of 1010
                1010 ^ 0010 (i=2) => 1000 only change one bit of 1010
                1010 ^ 0100 (i=3) => 1110 only change one bit of 1010
                1010 ^ 1000 (i=4) => 0010 only change one bit of 1010

4. if next not in HashSet => res.add(next) => if(res.size() == 1 << n) return true;

*/
public class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> res = new ArrayList<>();
        // Keeps track of the numbers present in the current sequence.
        HashSet<Integer> set = new HashSet<>();
        // All Gray code sequence starts with 0
        res.add(0);
        set.add(0);
        backTracking(res, set, n);

        return res;
    }

    boolean backTracking(List<Integer> res, HashSet<Integer> set, int n){
        if (res.size() == 1 << n) return true;

        int current = res.get(res.size() - 1);
        for (int i = 1; i <= n; i++){
            int next = current ^ ( 1 << i);
            if (!set.contains(next)){
                res.add(next);
                set.add(next);
                // If valid sequence found no need to search any further
                if (backTracking(res, set, n)) return true;
                //If no valid sequence found delete the last added number and continue the search.
                res.remove(res.size() - 1);
                set.remove(next);
            }
        }

        return false;
    }

    public static void main(String[] args) {
        System.out.println(1 << 2);
    }
}
