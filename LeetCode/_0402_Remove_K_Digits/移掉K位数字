### 解题思路
这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。

以题目中的 num = 1432219， k = 3 为例，我们需要返回一个长度为 4 的字符串，问题在于： 我们怎么才能求出这四个位置依次是什么呢？

暴力法的话，我们需要枚举C_n^(n - k) 种序列（其中 n 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。

一个思路是：
* 从左到右遍历
* 对于每一个遍历到的元素，我们决定是丢弃还是保留

问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？

这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a > b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小。

因此我们的思路就是：
* 从左到右遍历
* 对于遍历到的元素，我们选择保留。
* 但是我们可以选择性丢弃前面相邻的元素。
丢弃与否的依据如上面的前置知识中阐述中的方法。

然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。

一个简单的思路就是：
* 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。
* 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。

我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 n - kn−k 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前n - k个元素即可。

按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现

* 时间复杂度：虽然内层还有一个 while 循环，但是由于每个数字最多仅会入栈出栈一次，因此时间复杂度仍然为 O(N)，其中 N 为数字长度。
* 空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 O(N)，其中 N 为数字长度

作者：fe-lucifer
链接：https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
